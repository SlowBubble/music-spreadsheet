(function () {
    'use strict';

    const codeToHotkey = new Map([
        ["Escape", "esc"],
        ["CapsLock", "caps"],
        ["Backspace", "backspace"],
        ["Tab", "tab"],
        ["ArrowLeft", "left"],
        ["ArrowRight", "right"],
        ["ArrowDown", "down"],
        ["ArrowUp", "up"],
        ["Enter", "enter"],
        ["MetaLeft", "cmd"],
        ["ControlLeft", "ctrl"],
        ["ShiftLeft", "shift"],
        ["Home", "home"],
        ["End", "end"],
        ["PageUp", "pageup"],
        ["PageDown", "pagedown"],
        ["Space", "space"],
        // Numeric
        ["Digit1", "1"],
        [
            "Digit2",
            "2"
        ],
        [
            "Digit3",
            "3"
        ],
        [
            "Digit4",
            "4"
        ],
        [
            "Digit5",
            "5"
        ],
        [
            "Digit6",
            "6"
        ],
        [
            "Digit7",
            "7"
        ],
        [
            "Digit8",
            "8"
        ],
        [
            "Digit9",
            "9"
        ],
        [
            "Digit0",
            "0"
        ],
        // Symbols
        [
            "Backquote",
            "`"
        ],
        [
            "Minus",
            "-"
        ],
        [
            "Equal",
            "="
        ],
        // Letters
        [
            "KeyA",
            "a"
        ],
        [
            "KeyB",
            "b"
        ],
        [
            "KeyC",
            "c"
        ],
        [
            "KeyD",
            "d"
        ],
        [
            "KeyE",
            "e"
        ],
        [
            "KeyF",
            "f"
        ],
        [
            "KeyG",
            "g"
        ],
        [
            "KeyH",
            "h"
        ],
        [
            "KeyI",
            "i"
        ],
        [
            "KeyJ",
            "j"
        ],
        [
            "KeyK",
            "k"
        ],
        [
            "KeyL",
            "l"
        ],
        [
            "KeyM",
            "m"
        ],
        [
            "KeyN",
            "n"
        ],
        [
            "KeyO",
            "o"
        ],
        [
            "KeyP",
            "p"
        ],
        [
            "KeyQ",
            "q"
        ],
        [
            "KeyR",
            "r"
        ],
        [
            "KeyS",
            "s"
        ],
        [
            "KeyT",
            "t"
        ],
        [
            "KeyU",
            "u"
        ],
        [
            "KeyV",
            "v"
        ],
        [
            "KeyW",
            "w"
        ],
        [
            "KeyX",
            "x"
        ],
        [
            "KeyY",
            "y"
        ],
        [
            "KeyZ",
            "z"
        ]
    ]);
    // 0x001A	"BracketLeft"	"BracketLeft"
    // 0x001B	"BracketRight"	"BracketRight"
    // 0x001C	"Enter"	"Enter"
    // 0x001D	"ControlLeft"	"ControlLeft"
    // 0x001E	"KeyA"	"KeyA"
    // 0x001F	"KeyS"	"KeyS"
    // 0x0020	"KeyD"	"KeyD"
    // 0x0021	"KeyF"	"KeyF"
    // 0x0022	"KeyG"	"KeyG"
    // 0x0023	"KeyH"	"KeyH"
    // 0x0024	"KeyJ"	"KeyJ"
    // 0x0025	"KeyK"	"KeyK"
    // 0x0026	"KeyL"	"KeyL"
    // 0x0027	"Semicolon"	"Semicolon"
    // 0x0028	"Quote"	"Quote"
    // 0x0029	"Backquote"	"Backquote"
    // 0x002A	"ShiftLeft"	"ShiftLeft"
    // 0x002B	"Backslash"	"Backslash"
    // 0x002C	"KeyZ"	"KeyZ"
    // 0x002D	"KeyX"	"KeyX"
    // 0x002E	"KeyC"	"KeyC"
    // 0x002F	"KeyV"	"KeyV"
    // 0x0030	"KeyB"	"KeyB"
    // 0x0031	"KeyN"	"KeyN"
    // 0x0032	"KeyM"	"KeyM"
    // 0x0033	"Comma"	"Comma"
    // 0x0034	"Period"	"Period"
    // 0x0035	"Slash"	"Slash"
    // 0x0036	"ShiftRight"	"ShiftRight"
    // 0x0037	"NumpadMultiply"	"NumpadMultiply"
    // 0x0038	"AltLeft"	"AltLeft"
    // 0x0039	"Space"	"Space"
    // 0x003A	"CapsLock"	"CapsLock"

    function evtIsHotkey(evt, hotkeyStr) {
        return hotkeyInfoToStandardString(evtToHotkeyInfo(evt)) === toStandardString(hotkeyStr);
    }
    function evtIsLikelyInput(evt) {
        return (!evt.metaKey && !evt.ctrlKey && !evt.altKey &&
            evt.key.length === 1);
    }
    // Order: cmd/ctrl/alt/shift
    function toStandardString(hotkeyStr) {
        const strs = hotkeyStr.split(' ');
        const endKey = strs[strs.length - 1];
        const hotkeyInfo = new HotkeyInfo(endKey);
        const set = new Set(strs);
        if (set.has('cmd')) {
            // Mac OS
            hotkeyInfo.metaKey = true;
        }
        if (set.has('ctrl')) {
            // Mac OS
            hotkeyInfo.ctrlKey = true;
        }
        if (set.has('shift')) {
            hotkeyInfo.shiftKey = true;
        }
        if (set.has('alt')) {
            hotkeyInfo.altKey = true;
        }
        return hotkeyInfoToStandardString(hotkeyInfo);
    }
    class HotkeyInfo {
        constructor(endKey = '', metaKey = false, ctrlKey = false, shiftKey = false, altKey = false) {
            this.endKey = endKey;
            this.metaKey = metaKey;
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
            this.altKey = altKey;
        }
    }
    function evtToHotkeyInfo(evt) {
        const info = new HotkeyInfo();
        const possHotkey = codeToHotkey.get(evt.code);
        if (!possHotkey) {
            throw new Error(`Unknown endKey for evtcode: ${evt.code}`);
        }
        info.endKey = possHotkey;
        info.metaKey = evt.metaKey;
        info.ctrlKey = evt.ctrlKey;
        info.shiftKey = evt.shiftKey;
        info.altKey = evt.altKey;
        return info;
    }
    function hotkeyInfoToStandardString(info) {
        const strs = [];
        if (info.metaKey) {
            strs.push('cmd');
        }
        if (info.ctrlKey) {
            strs.push('ctrl');
        }
        if (info.shiftKey) {
            strs.push('shift');
        }
        if (info.altKey) {
            strs.push('alt');
        }
        strs.push(info.endKey);
        return strs.join(' ');
    }

    class Cell {
        constructor(text = '') {
            this.text = text;
        }
    }

    const COLUMN_DELIMITER = ' | ';
    const ROW_DELIMITER = '\n';
    class TextTable {
        constructor(cells = [[new Cell()]], columnDelimiter = COLUMN_DELIMITER) {
            this.cells = cells;
            this.columnDelimiter = columnDelimiter;
        }
        static fromString(str, columnDelimiter = COLUMN_DELIMITER) {
            return new TextTable(stringToCells(str), columnDelimiter);
        }
        toString() {
            return this.cells.map(row => row.map(cell => cell.text).join(this.columnDelimiter)).join(ROW_DELIMITER);
        }
        getCellsInArray() {
            return this.cells.flatMap(row => row);
        }
        applyLint() {
            // Remove consecutive spaces
            this.getCellsInArray().forEach(cell => stripConsecutiveSpaces(cell.text));
            // Make each column have the same number of spaces
            const rowDimensions = this.cells.map(row => row.length);
            const tranposedCells = getTransposedCells(this.cells);
            const paddedCells = getTransposedCells(tranposedCells.map(colOfCells => genColOfPaddedCells(colOfCells)));
            this.cells = getSubCells(paddedCells, rowDimensions);
        }
        getCellAndInsertIfAbsent(row, col) {
            if (!this.isWithinBound(row, col)) {
                this.insertEmptyCellIfAbsent(row, col);
            }
            return this.cells[row][col];
        }
        insertEmptyCellIfAbsent(row, col) {
            while (row >= this.cells.length) {
                this.cells.push([]);
            }
            while (col >= this.cells[row].length) {
                this.cells[row].push(new Cell());
            }
        }
        isWithinBound(row, col) {
            if (row < 0 || row >= this.cells.length) {
                return false;
            }
            if (col < 0 || col >= this.cells[row].length) {
                return false;
            }
            return true;
        }
    }
    ////// Functional functions (i.e. no mutation)
    function getSubCells(cells, rowDimensions) {
        return cells.map((row, i) => rowDimensions[i] > 0 ? row.slice(0, rowDimensions[i]) : []);
    }
    // Take into account that each row may have a different number of columns
    // by filling in empty cells with empty strings (which will change the overall dims)
    function getTransposedCells(cells) {
        const transposedCells = [];
        const numOfColsByRow = cells.map(row => row.length);
        const maxNumOfCols = Math.max(...numOfColsByRow);
        for (let i = 0; i < maxNumOfCols; i++) {
            transposedCells.push(getColumnsOfCells(cells, i));
        }
        return transposedCells;
    }
    function stripConsecutiveSpaces(str) {
        return str.replace(/\s+/g, ' ');
    }
    function stringToCells(str, columnDelimiter = COLUMN_DELIMITER) {
        return str.split(ROW_DELIMITER).map(row => row.split(columnDelimiter).map(text => new Cell(text)));
    }
    function getColumnsOfCells(cells, columnIdx) {
        return cells.map(row => columnIdx < row.length ? row[columnIdx] : new Cell(''));
    }
    function genColOfPaddedCells(colsOfCells) {
        const maxWidth = Math.max(...colsOfCells.map(c => c.text.length));
        return colsOfCells
            .map(c => c.text + ' '.repeat(maxWidth - c.text.length))
            .map(text => new Cell(text));
    }

    class TsCursor {
        constructor(rowIdx = 0, colIdx = 0, inTextMode = false, 
        // Relevant only in text mode
        textIdx = 0, inTextSelectionMode = false, 
        // Relevant only in text selection mode
        textEndIdx = 0) {
            this.rowIdx = rowIdx;
            this.colIdx = colIdx;
            this.inTextMode = inTextMode;
            this.textIdx = textIdx;
            this.inTextSelectionMode = inTextSelectionMode;
            this.textEndIdx = textEndIdx;
        }
        // Note that the cursor is not aware of being out-of-bound.
        // It's the responsibility of the editor to ensure that.
        moveToRightCell() {
            this.colIdx++;
            this.inTextMode = false;
        }
        moveToLeftCell() {
            this.colIdx--;
            if (this.colIdx < 0) {
                this.colIdx = 0;
            }
            this.inTextMode = false;
        }
        moveToBelowCell() {
            this.rowIdx++;
            this.inTextMode = false;
        }
        moveToAboveCell() {
            this.rowIdx--;
            if (this.rowIdx < 0) {
                this.rowIdx = 0;
            }
            this.inTextMode = false;
        }
    }

    function shouldRerenderAndPreventDefault() {
        return {
            rerender: true,
            applyBrowserDefault: false,
        };
    }
    function shouldApplyBrowserDefaultWithoutRerendering() {
        return {
            rerender: false,
            applyBrowserDefault: true,
        };
    }
    function shouldPreventDefaultWithoutRerendering() {
        return {
            rerender: false,
            applyBrowserDefault: false,
        };
    }
    class TsEditor {
        constructor(
        // I/O
        textarea, 
        // Model; public to allow for the lowest-level operations
        textTable = new TextTable(), cursor = new TsCursor(), keydownHandler = undefined) {
            this.textarea = textarea;
            this.textTable = textTable;
            this.cursor = cursor;
            this.keydownHandler = keydownHandler;
            this.textarea.onkeydown = evt => this.handleTextareaKeydown(evt);
            this.textarea.onclick = evt => {
                // TODO use the selection range to determine which cell the cursor should be on
            };
        }
        render() {
            console.log('lint + update cursor');
            this.textTable.applyLint();
            this.textarea.value = this.textTable.toString();
            this.updateTextareaSelectionFromCursors();
        }
        updateTextareaSelectionFromCursors() {
            this.textarea.selectionStart = this.inferSelectionStart();
            this.textarea.selectionEnd = this.inferSelectionEnd();
        }
        //// Event processing  ////
        // Allow client to specify custom keydown handler.
        onKeydown(handler) {
            this.keydownHandler = handler;
        }
        handleTextareaKeydown(evt) {
            const handleKeyDown = this.keydownHandler ? this.keydownHandler : this.defaultKeydownHandler;
            const handlerOutput = handleKeyDown(evt);
            if (!handlerOutput.applyBrowserDefault) {
                evt.preventDefault();
            }
            if (handlerOutput.rerender) {
                this.render();
            }
        }
        handleTextInput(str) {
            const currCell = this.getCurrCell();
            if (!this.cursor.inTextMode) {
                currCell.text = str;
                this.cursor.inTextMode = true;
                this.cursor.textIdx = str.length;
                return;
            }
            if (!this.cursor.inTextSelectionMode) {
                // TODO splice based on textIdx
                const oldText = currCell.text;
                currCell.text = oldText.slice(0, this.cursor.textIdx) + str + oldText.slice(this.cursor.textIdx);
                this.cursor.textIdx += str.length;
                return;
            }
            // TODO: handle textSelectionMode
        }
        defaultKeydownHandler(evt) {
            if (evtIsLikelyInput(evt)) {
                this.handleTextInput(evt.key);
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'tab')) {
                this.moveToRightCell();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'shift tab')) {
                this.moveLeftOrUpAndRight();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'enter')) {
                if (!this.cursor.inTextMode) {
                    this.enterTextMode();
                    return shouldRerenderAndPreventDefault();
                }
                this.moveDownToLeftmostColumn();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'left')) {
                this.moveLeft();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'right')) {
                this.moveRight();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'up')) {
                this.moveUp();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'down')) {
                this.moveDown();
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'backspace')) {
                const hasChanged = this.removeTextOrMoveBack();
                if (!hasChanged) {
                    this.moveLeftOrUpAndRight();
                }
                return shouldRerenderAndPreventDefault();
            }
            if (evtIsHotkey(evt, 'cmd backspace')) {
                const hasChanged = this.removeTextOrMoveBack(true);
                if (!hasChanged) {
                    this.moveLeftOrUpAndRight();
                }
                return shouldRerenderAndPreventDefault();
            }
            return shouldApplyBrowserDefaultWithoutRerendering();
        }
        //removeEntireWord: removes until a space is encountered.
        // Returns whether or not there is anything removed.
        removeTextOrMoveBack(removeEntireWord = false) {
            const currCell = this.getCurrCell();
            if (this.cursor.inTextMode) {
                if (this.cursor.textIdx === 0) {
                    return false;
                }
                if (!removeEntireWord) {
                    currCell.text = currCell.text.slice(0, this.cursor.textIdx - 1) + currCell.text.slice(this.cursor.textIdx);
                    this.cursor.textIdx -= 1;
                    return true;
                }
                const tokens = currCell.text.slice(0, this.cursor.textIdx).trimEnd().split(/(\s+)/);
                const resultingSubstr = tokens.slice(0, tokens.length - 1).join('');
                currCell.text = resultingSubstr + currCell.text.slice(this.cursor.textIdx);
                this.cursor.textIdx = resultingSubstr.length;
                return true;
            }
            if (currCell.text.trimEnd().length > 0) {
                currCell.text = '';
                return true;
            }
            return false;
        }
        moveLeftOrUpAndRight(removeCurrCellIfNoCellToRight = false) {
            // TODO remove the current cell there is if no more cell to the right.
            // TODO If at left boundary, move up to right most cell
            this.moveToLeftCell();
        }
        getCurrCell() {
            return this.textTable.getCellAndInsertIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
        }
        moveRight() {
            if (this.cursor.inTextMode && this.cursor.textIdx < this.getCurrCell().text.trimEnd().length) {
                this.cursor.textIdx += 1;
                return;
            }
            this.moveToRightCell();
        }
        moveToRightCell() {
            this.cursor.moveToRightCell();
            this.textTable.insertEmptyCellIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
        }
        moveLeft() {
            if (this.cursor.inTextMode && this.cursor.textIdx > 0) {
                this.cursor.textIdx -= 1;
                return;
            }
            this.moveToLeftCell();
        }
        moveToLeftCell() {
            this.cursor.moveToLeftCell();
            this.textTable.insertEmptyCellIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
        }
        moveUp() {
            this.cursor.moveToAboveCell();
            this.textTable.insertEmptyCellIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
        }
        moveDown() {
            this.cursor.moveToBelowCell();
            this.textTable.insertEmptyCellIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
        }
        moveDownToLeftmostColumn() {
            this.cursor.moveToBelowCell();
            this.cursor.colIdx = 0;
            this.textTable.insertEmptyCellIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
        }
        enterTextMode() {
            this.cursor.inTextMode = true;
            const currCell = this.textTable.getCellAndInsertIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
            this.cursor.textIdx = currCell.text.trimEnd().length;
        }
        // Helpers
        inferSelectionStart() {
            let idx = 0;
            const text = this.textarea.value;
            text.split(ROW_DELIMITER).forEach((line, i) => {
                if (i > this.cursor.rowIdx) {
                    return;
                }
                if (i === this.cursor.rowIdx) {
                    line.split(COLUMN_DELIMITER).forEach((cellText, j) => {
                        if (j > this.cursor.colIdx) {
                            return;
                        }
                        if (j === this.cursor.colIdx) {
                            if (this.cursor.inTextMode) {
                                idx += this.cursor.textIdx;
                            }
                            return;
                        }
                        idx += cellText.length + COLUMN_DELIMITER.length;
                    });
                    return;
                }
                idx += line.length + ROW_DELIMITER.length;
            });
            return idx;
        }
        inferSelectionEnd() {
            let idx = this.inferSelectionStart();
            if (this.cursor.inTextMode) {
                if (this.cursor.inTextSelectionMode) {
                    return idx + this.cursor.textEndIdx;
                }
                return idx;
            }
            const currCell = this.textTable.cells[this.cursor.rowIdx][this.cursor.colIdx];
            // add one so that for zero length text, user can still see the cell selected.
            const textLength = currCell.text.trimEnd().length;
            if (textLength === 0) {
                return idx + 1;
            }
            return idx + textLength;
        }
    }

    class TsUi extends HTMLElement {
        constructor(tsEditor) {
            super();
            this.tsEditor = tsEditor;
        }
        connectedCallback() {
            const shadowRoot = this.attachShadow({ mode: 'open' });
            const textarea = document.createElement('textarea');
            textarea.id = 'editing-textarea';
            textarea.style.width = '100%';
            textarea.style.fontSize = '24px';
            textarea.rows = 20;
            textarea.spellcheck = false;
            textarea.autofocus = true;
            shadowRoot.appendChild(textarea);
            this.tsEditor = new TsEditor(textarea);
        }
    }
    customElements.define('textarea-spreadsheet-ui', TsUi);

    class MsEditor {
        constructor(tsEditor, numFullBarsPerRow = 4) {
            this.tsEditor = tsEditor;
            this.numFullBarsPerRow = numFullBarsPerRow;
            this.buffer = [];
            this.tsEditor.onKeydown(evt => this.handleKeyDown(evt));
        }
        handleKeyDown(evt) {
            // Need to disable custom behavior to avoid infinite loop.
            this.buffer.push(evt);
            window.setTimeout(() => {
                // Special keys should come before other keys
                this.buffer.sort((evt1, evt2) => {
                    const isSpecialKey = evtIsHotkey(evt1, 'tab') || evtIsHotkey(evt1, '`');
                    const isSpecialKey2 = evtIsHotkey(evt2, 'tab') || evtIsHotkey(evt2, '`');
                    if (!isSpecialKey && isSpecialKey2) {
                        return 1;
                    }
                    return -1;
                });
                let rerender = false;
                this.buffer.forEach(evt => {
                    rerender = rerender || this.handleKeyDownAfterOrdering(evt);
                });
                this.buffer = [];
                if (rerender) {
                    this.tsEditor.render();
                }
            }, 100);
            // Browser default needs to be explicitly enabled.
            if (evtIsHotkey(evt, 'cmd r'))
                return shouldApplyBrowserDefaultWithoutRerendering();
            if (evtIsHotkey(evt, 'cmd c'))
                return shouldApplyBrowserDefaultWithoutRerendering();
            if (evtIsHotkey(evt, 'cmd x'))
                return shouldApplyBrowserDefaultWithoutRerendering();
            // No-op because we will handle it in handleKeyDownAfterOrdering.
            return shouldPreventDefaultWithoutRerendering();
        }
        // Returns whether or not to re-render.
        handleKeyDownAfterOrdering(evt) {
            if (evtIsHotkey(evt, '`')) {
                this.addDivider();
                return true;
            }
            if (evtIsHotkey(evt, 'space')) {
                this.addProtraction();
                return true;
            }
            if (evtIsLikelyInput(evt)) {
                const possNoteNum = mapKeyToNoteNum(evt.key);
                if (possNoteNum) {
                    const abc = noteNumToAbc(possNoteNum);
                    this.handleTextInputWithPadding(abc);
                    return true;
                }
            }
            if (evtIsHotkey(evt, 'tab')) {
                if (this.tsEditor.cursor.colIdx < this.numFullBarsPerRow) {
                    this.tsEditor.moveToRightCell();
                    return true;
                }
                this.tsEditor.moveDownToLeftmostColumn();
                // Move right before the left-most cell is the pick-up bar.
                this.tsEditor.moveToRightCell();
                return true;
            }
            if (evtIsHotkey(evt, 'backspace')) {
                const hasChanged = this.tsEditor.removeTextOrMoveBack(true);
                if (!hasChanged) {
                    this.moveLeftOrUpAndRight();
                }
            }
            return false;
        }
        customMoveLeftOrUpAndRight(removeCurrCellIfNoCellToRight = false) {
        }
        addDivider() {
            this.handleTextInputWithPadding(';');
        }
        addProtraction() {
            this.handleTextInputWithPadding('_');
        }
        handleTextInputWithPadding(text) {
            const cursor = this.tsEditor.cursor;
            let paddedText = ` ${text} `;
            if (!cursor.inTextMode || cursor.textIdx === 0) {
                paddedText = `${text} `;
            }
            else if (this.tsEditor.getCurrCell().text.slice(cursor.textIdx - 1, cursor.textIdx) === ' ') {
                paddedText = `${text} `;
            }
            this.tsEditor.handleTextInput(paddedText);
        }
    }
    const keyToNoteNum = new Map([
        ['1', 60],
        ['2', 62],
        ['3', 64],
        ['4', 65],
        ['5', 67],
        ['6', 69],
        ['7', 71],
        ['8', 72],
        ['9', 74],
        ['0', 76],
    ]);
    function mapKeyToNoteNum(key) {
        return keyToNoteNum.get(key);
    }
    const modNoteNumToAbc = new Map([
        [0, 'C'],
        [1, 'C#'],
        [2, 'D'],
        [3, 'Eb'],
        [4, 'E'],
        [5, 'F'],
        [6, 'F#'],
        [7, 'G'],
        [8, 'G#'],
        [9, 'A'],
        [10, 'Bb'],
        [11, 'B'],
    ]);
    function noteNumToAbc(noteNum) {
        const possibleStr = modNoteNumToAbc.get(mod(noteNum, 12));
        if (!possibleStr) {
            throw new Error('Invalid noteNum: ' + noteNum);
        }
        return possibleStr;
    }
    function mod(a, b) {
        return (a % b + b) % b;
    }

    class MsUi extends HTMLElement {
        constructor(msEditor) {
            super();
            this.msEditor = msEditor;
        }
        connectedCallback() {
            const shadowRoot = this.attachShadow({ mode: 'open' });
            const tsUi = document.createElement('textarea-spreadsheet-ui');
            shadowRoot.appendChild(tsUi);
            this.msEditor = new MsEditor(tsUi.tsEditor);
        }
    }
    customElements.define('music-spreadsheet-ui', MsUi);

})();
//# sourceMappingURL=main.min.js.map
