(function () {
    'use strict';

    const codeToHotkey = new Map([
        ["Escape", "esc"],
        ["CapsLock", "caps"],
        ["Backspace", "backspace"],
        ["Tab", "tab"],
        ["ArrowLeft", "left"],
        ["ArrowRight", "right"],
        ["ArrowDown", "down"],
        ["ArrowUp", "up"],
        ["Enter", "enter"],
        ["MetaLeft", "cmd"],
        ["ControlLeft", "ctrl"],
        ["ShiftLeft", "shift"],
        ["Home", "home"],
        ["End", "end"],
        ["PageUp", "pageup"],
        ["PageDown", "pagedown"],
        // Numeric
        ["Digit1", "1"],
        [
            "Digit2",
            "2"
        ],
        [
            "Digit3",
            "3"
        ],
        [
            "Digit4",
            "4"
        ],
        [
            "Digit5",
            "5"
        ],
        [
            "Digit6",
            "6"
        ],
        [
            "Digit7",
            "7"
        ],
        [
            "Digit8",
            "8"
        ],
        [
            "Digit9",
            "9"
        ],
        [
            "Digit0",
            "0"
        ],
        // Symbols
        [
            "Backquote",
            "`"
        ],
        [
            "Minus",
            "-"
        ],
        [
            "Equal",
            "="
        ],
        // Letters
        [
            "KeyA",
            "a"
        ],
        [
            "KeyB",
            "b"
        ],
        [
            "KeyC",
            "c"
        ],
        [
            "KeyD",
            "d"
        ],
        [
            "KeyE",
            "e"
        ],
        [
            "KeyF",
            "f"
        ],
        [
            "KeyG",
            "g"
        ],
        [
            "KeyH",
            "h"
        ],
        [
            "KeyI",
            "i"
        ],
        [
            "KeyJ",
            "j"
        ],
        [
            "KeyK",
            "k"
        ],
        [
            "KeyL",
            "l"
        ],
        [
            "KeyM",
            "m"
        ],
        [
            "KeyN",
            "n"
        ],
        [
            "KeyO",
            "o"
        ],
        [
            "KeyP",
            "p"
        ],
        [
            "KeyQ",
            "q"
        ],
        [
            "KeyR",
            "r"
        ],
        [
            "KeyS",
            "s"
        ],
        [
            "KeyT",
            "t"
        ],
        [
            "KeyU",
            "u"
        ],
        [
            "KeyV",
            "v"
        ],
        [
            "KeyW",
            "w"
        ],
        [
            "KeyX",
            "x"
        ],
        [
            "KeyY",
            "y"
        ],
        [
            "KeyZ",
            "z"
        ]
    ]);
    // 0x001A	"BracketLeft"	"BracketLeft"
    // 0x001B	"BracketRight"	"BracketRight"
    // 0x001C	"Enter"	"Enter"
    // 0x001D	"ControlLeft"	"ControlLeft"
    // 0x001E	"KeyA"	"KeyA"
    // 0x001F	"KeyS"	"KeyS"
    // 0x0020	"KeyD"	"KeyD"
    // 0x0021	"KeyF"	"KeyF"
    // 0x0022	"KeyG"	"KeyG"
    // 0x0023	"KeyH"	"KeyH"
    // 0x0024	"KeyJ"	"KeyJ"
    // 0x0025	"KeyK"	"KeyK"
    // 0x0026	"KeyL"	"KeyL"
    // 0x0027	"Semicolon"	"Semicolon"
    // 0x0028	"Quote"	"Quote"
    // 0x0029	"Backquote"	"Backquote"
    // 0x002A	"ShiftLeft"	"ShiftLeft"
    // 0x002B	"Backslash"	"Backslash"
    // 0x002C	"KeyZ"	"KeyZ"
    // 0x002D	"KeyX"	"KeyX"
    // 0x002E	"KeyC"	"KeyC"
    // 0x002F	"KeyV"	"KeyV"
    // 0x0030	"KeyB"	"KeyB"
    // 0x0031	"KeyN"	"KeyN"
    // 0x0032	"KeyM"	"KeyM"
    // 0x0033	"Comma"	"Comma"
    // 0x0034	"Period"	"Period"
    // 0x0035	"Slash"	"Slash"
    // 0x0036	"ShiftRight"	"ShiftRight"
    // 0x0037	"NumpadMultiply"	"NumpadMultiply"
    // 0x0038	"AltLeft"	"AltLeft"
    // 0x0039	"Space"	"Space"
    // 0x003A	"CapsLock"	"CapsLock"

    function evtIsHotkey(evt, hotkeyStr) {
        return hotkeyInfoToStandardString(evtToHotkeyInfo(evt)) === toStandardString(hotkeyStr);
    }
    function evtIsLikelyInput(evt) {
        return (!evt.metaKey && !evt.ctrlKey && !evt.altKey &&
            evt.key.length === 1);
    }
    // Order: cmd/ctrl/alt/shift
    function toStandardString(hotkeyStr) {
        const strs = hotkeyStr.split(' ');
        const endKey = strs[strs.length - 1];
        const hotkeyInfo = new HotkeyInfo(endKey);
        const set = new Set(strs);
        if (set.has('cmd')) {
            // Mac OS
            hotkeyInfo.metaKey = true;
        }
        if (set.has('ctrl')) {
            // Mac OS
            hotkeyInfo.ctrlKey = true;
        }
        if (set.has('shift')) {
            hotkeyInfo.shiftKey = true;
        }
        if (set.has('alt')) {
            hotkeyInfo.altKey = true;
        }
        return hotkeyInfoToStandardString(hotkeyInfo);
    }
    class HotkeyInfo {
        constructor(endKey = '', metaKey = false, ctrlKey = false, shiftKey = false, altKey = false) {
            this.endKey = endKey;
            this.metaKey = metaKey;
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
            this.altKey = altKey;
        }
    }
    function evtToHotkeyInfo(evt) {
        const info = new HotkeyInfo();
        const possHotkey = codeToHotkey.get(evt.code);
        if (!possHotkey) {
            throw new Error(`Unknown endKey for evtcode: ${evt.code}`);
        }
        info.endKey = possHotkey;
        info.metaKey = evt.metaKey;
        info.ctrlKey = evt.ctrlKey;
        info.shiftKey = evt.shiftKey;
        info.altKey = evt.altKey;
        return info;
    }
    function hotkeyInfoToStandardString(info) {
        const strs = [];
        if (info.metaKey) {
            strs.push('cmd');
        }
        if (info.ctrlKey) {
            strs.push('ctrl');
        }
        if (info.shiftKey) {
            strs.push('shift');
        }
        if (info.altKey) {
            strs.push('alt');
        }
        strs.push(info.endKey);
        return strs.join(' ');
    }

    class Cell {
        constructor(text = '') {
            this.text = text;
        }
    }

    const COLUMN_DELIMITER = ' | ';
    const ROW_DELIMITER = '\n';
    class TextTable {
        constructor(cells = [[new Cell('')]], columnDelimiter = COLUMN_DELIMITER) {
            this.cells = cells;
            this.columnDelimiter = columnDelimiter;
        }
        static fromString(str, columnDelimiter = COLUMN_DELIMITER) {
            return new TextTable(stringToCells(str), columnDelimiter);
        }
        toString() {
            return this.cells.map(row => row.map(cell => cell.text).join(this.columnDelimiter)).join(ROW_DELIMITER);
        }
        getCellsInArray() {
            return this.cells.flatMap(row => row);
        }
        applyLint() {
            // Remove consecutive spaces
            this.getCellsInArray().forEach(cell => stripConsecutiveSpaces(cell.text));
            // Make each column have the same number of spaces
            const rowDimensions = this.cells.map(row => row.length);
            const tranposedCells = getTransposedCells(this.cells);
            const paddedCells = getTransposedCells(tranposedCells.map(colOfCells => genColOfPaddedCells(colOfCells)));
            this.cells = getSubCells(paddedCells, rowDimensions);
        }
        getCellAndInsertIfAbsent(row, col) {
            if (!this.isWithinBound(row, col)) {
                this.insertEmptyCellIfAbsent(row, col);
            }
            return this.cells[row][col];
        }
        insertEmptyCellIfAbsent(row, col) {
            while (row >= this.cells.length) {
                this.cells.push([]);
            }
            while (col >= this.cells[row].length) {
                this.cells[row].push(new Cell());
            }
        }
        isWithinBound(row, col) {
            if (row < 0 || row >= this.cells.length) {
                return false;
            }
            if (col < 0 || col >= this.cells[row].length) {
                return false;
            }
            return true;
        }
    }
    ////// Functional functions (i.e. no mutation)
    function getSubCells(cells, rowDimensions) {
        return cells.map((row, i) => rowDimensions[i] > 0 ? row.slice(0, rowDimensions[i]) : []);
    }
    // Take into account that each row may have a different number of columns
    // by filling in empty cells with empty strings (which will change the overall dims)
    function getTransposedCells(cells) {
        const transposedCells = [];
        const numOfColsByRow = cells.map(row => row.length);
        const maxNumOfCols = Math.max(...numOfColsByRow);
        for (let i = 0; i < maxNumOfCols; i++) {
            transposedCells.push(getColumnsOfCells(cells, i));
        }
        return transposedCells;
    }
    function stripConsecutiveSpaces(str) {
        return str.replace(/\s+/g, ' ');
    }
    function stringToCells(str, columnDelimiter = COLUMN_DELIMITER) {
        return str.split(ROW_DELIMITER).map(row => row.split(columnDelimiter).map(text => new Cell(text)));
    }
    function getColumnsOfCells(cells, columnIdx) {
        return cells.map(row => columnIdx < row.length ? row[columnIdx] : new Cell(''));
    }
    function genColOfPaddedCells(colsOfCells) {
        const maxWidth = Math.max(...colsOfCells.map(c => c.text.length));
        return colsOfCells
            .map(c => c.text + ' '.repeat(maxWidth - c.text.length))
            .map(text => new Cell(text));
    }

    class TsCursor {
        constructor(rowIdx = 0, colIdx = 0, inTextMode = false, 
        // Relevant only in text mode
        textIdx = 0, inTextSelectionMode = false, 
        // Relevant only in text selection mode
        textEndIdx = 0) {
            this.rowIdx = rowIdx;
            this.colIdx = colIdx;
            this.inTextMode = inTextMode;
            this.textIdx = textIdx;
            this.inTextSelectionMode = inTextSelectionMode;
            this.textEndIdx = textEndIdx;
        }
        moveToRightCell() {
            this.colIdx++;
            this.inTextMode = false;
        }
        moveToLeftCell() {
            this.colIdx--;
            this.inTextMode = false;
        }
    }

    class TsEditor {
        constructor(
        // I/O
        textarea, 
        // Model; public to allow for the lowest-level operations
        textTable = new TextTable(), cursor = new TsCursor(), manualMode = false, customKeydownHandler = undefined) {
            this.textarea = textarea;
            this.textTable = textTable;
            this.cursor = cursor;
            this.manualMode = manualMode;
            this.customKeydownHandler = customKeydownHandler;
            this.textarea.onkeydown = evt => {
                this.handleTextareaKeydown(evt);
                this.render();
            };
        }
        render() {
            this.textTable.applyLint();
            this.textarea.value = this.textTable.toString();
            this.updateTextareaSelectionFromCursors();
        }
        updateTextareaSelectionFromCursors() {
        }
        //// Event processing  ////
        // Allow client to specify custom keydown handler.
        onKeydown(handler) {
            this.customKeydownHandler = handler;
        }
        handleTextareaKeydown(evt) {
            if (this.manualMode) {
                return;
            }
            if (this.customKeydownHandler) {
                this.customKeydownHandler(evt);
            }
            if (evt.defaultPrevented) {
                return;
            }
            this.defaultWayToHandleKeydown(evt);
            evt.preventDefault();
        }
        defaultWayToHandleKeydown(evt) {
            console.log('Default TextareaSpreadsheet keydown handler');
            if (evtIsLikelyInput(evt)) {
                const currCell = this.textTable.getCellAndInsertIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
                if (!this.cursor.inTextMode) {
                    currCell.text = evt.key;
                    this.cursor.inTextMode = true;
                    return;
                }
                if (!this.cursor.inTextSelectionMode) {
                    currCell.text += evt.key;
                    return;
                }
                // TODO: handle text selection mode
                return;
            }
            if (evtIsHotkey(evt, 'tab')) {
                this.cursor.moveToRightCell();
                this.textTable.insertEmptyCellIfAbsent(this.cursor.rowIdx, this.cursor.colIdx);
            }
        }
        //// Write helpers ////
        setCell(rowIdx, colIdx, value) {
            // TODO insert rows and columns if necessary
            // this.rows[rowIdx][colIdx] = value;
        }
        insertNewRow(rowIdx) {
            // this.rows.splice(rowIdx, 0, []);
        }
        insertNewColumn(colIdx) {
            // for (let row of this.rows) {
            //   row.splice(colIdx, 0, '');
            // }
        }
        //// Navigation helpers  ////
        enterPlainTextMode() {
        }
        enterCellMode() {
        }
        moveToRightCell() {
        }
        moveToLeftCell() {
        }
        moveToAboveCell() {
        }
        moveToBelowCell() {
        }
    }

    class TsUi extends HTMLElement {
        constructor(tsEditor) {
            super();
            this.tsEditor = tsEditor;
        }
        connectedCallback() {
            const shadowRoot = this.attachShadow({ mode: 'open' });
            const textarea = document.createElement('textarea');
            textarea.id = 'editing-textarea';
            textarea.style.width = '100%';
            textarea.rows = 20;
            textarea.spellcheck = false;
            textarea.autofocus = true;
            shadowRoot.appendChild(textarea);
            this.tsEditor = new TsEditor(textarea);
        }
    }
    customElements.define('textarea-spreadsheet-ui', TsUi);

})();
//# sourceMappingURL=main.min.js.map
